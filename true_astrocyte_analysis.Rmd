Astrocyte Specific Anlalysis and pseudobulk
Tasks to complete
0. Standard seurat preprocessing workflow
1. Map row ids to sample id, and AD status.
2. View batch via UMAP to check for batch effects
3. Run UMAP for AD status
4. Pseudobulk, watch bioinformagician for more details

loading libraries
```{r}
library(Seurat)
library(tidyverse)
```

```{r}
raw_data <- read.csv("/Users/yonatan/Desktop/Single_Cell_Proj/AQP4_snRNA_project/AQP4_Expression_snRNA_seq/Code_and_writeup/Single_Cell_Astrocyte_Project/astros_I_found.csv", row.names = 1)
astro_data <- CreateSeuratObject(raw_data)
```

Standard preprocessing checks
```{r}
astro_data@meta.data
astro_data[["percent.mt"]] <- PercentageFeatureSet(astro_data, pattern = "^mt-")
# Visualize QC metrics as a violin plot
VlnPlot(astro_data, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, pt.size = 0)
FeatureScatter(astro_data, feature1 = "nCount_RNA", feature2 = "percent.mt")
FeatureScatter(astro_data, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

```
I already did QC before, so I will not change anything this time, since global QC on all nuclei was already performed.

# Adding AD status to cell metadata
```{r}
astro_data@meta.data$full_meta_data <- rownames(astro_data@meta.data)
astro_data@meta.data
# Assumes the column name is 'cell_id'
astro_data@meta.data$batch_id_sample_id <- substr(
  astro_data@meta.data$full_meta_data, 
  start = 1, 
  stop = nchar(astro_data@meta.data$full_meta_data) - 16
)
unique(astro_data@meta.data$batch_id_sample_id)
```
# Mapping those ids to sample IDs and AD status, and sex
```{r}
# Define the mapping
genotype_map <- c(
  "NP40.Batch1_Untreated.Hip.S2.R_" = "AD",
  "NP40.Batch1_Wt.Hip.S2.R_"        = "WT",
  "EZ.Batch1_HipR.WT.G3.2w_"        = "WT",
  "EZ.Batch1_HipR.AD.G1.4w_"        = "AD",
  "EZ.Batch1_HipR.AD.G3.2w_"        = "AD",
  "EZ.Batch1_HipR.WT.G1.4w_"        = "WT",
  "NP40.Batch3_Untreated.Hip.S1.L_" = "AD",
  "NP40.Batch3_Untreated.Hip.S2.L_" = "AD",
  "NP40.Batch3_Wt.Hip.S1.L_"        = "WT",
  "NP40.Batch3_Wt.Hip.S2.L_"        = "WT"
)

sample_id_map <- c(
  "NP40.Batch1_Untreated.Hip.S2.R_" = "sample_1",
  "NP40.Batch1_Wt.Hip.S2.R_"        = "sample_2",
  "EZ.Batch1_HipR.WT.G3.2w_"        = "sample_3",
  "EZ.Batch1_HipR.AD.G1.4w_"        = "sample_4",
  "EZ.Batch1_HipR.AD.G3.2w_"        = "sample_5",
  "EZ.Batch1_HipR.WT.G1.4w_"        = "sample_6",
  "NP40.Batch3_Untreated.Hip.S1.L_" = "sample_7",
  "NP40.Batch3_Untreated.Hip.S2.L_" = "sample_8",
  "NP40.Batch3_Wt.Hip.S1.L_"        = "sample_9",
  "NP40.Batch3_Wt.Hip.S2.L_"        = "sample_10"
)

# Apply mapping to your metadata, AD Status and sample ID
# Replace 'sample_id' with your actual column name
astro_data@meta.data$AD_STATUS <- genotype_map[astro_data@meta.data$batch_id_sample_id]

astro_data@meta.data$sample_id <- sample_id_map[astro_data@meta.data$batch_id_sample_id]

unique(astro_data@meta.data$AD_STATUS)
astro_data@meta.data
```


Normalize, identify highly variable features, and scaling the data.

```{r}
astro_data <- NormalizeData(astro_data, normalization.method = "LogNormalize", scale.factor = 10000)
astro_data <- FindVariableFeatures(astro_data, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(astro_data), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(astro_data)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1
plot2

all.genes <- rownames(astro_data)
astro_data <- ScaleData(astro_data, features = all.genes)
```

```{r}
astro_data <- RunPCA(astro_data, features = VariableFeatures(object = astro_data))
ElbowPlot(astro_data)
DimPlot(astro_data, reduction = "pca", label = TRUE) + NoLegend()
```

```{r}
astro_data <- FindNeighbors(astro_data, dims = 1:12)
astro_data <- FindClusters(astro_data, resolution = 0.5)
```
```{r}
astro_data <- RunUMAP(astro_data, dims = 1:10)
DimPlot(astro_data, reduction = "umap", group.by='AD_STATUS')

DimPlot(astro_data, reduction = "umap", group.by='orig.ident')
```

### PSEUDOBULKING TIME 
Loading the packages
```{r}
library(Seurat)
library(tidyverse)
library(DESeq2)
library(pheatmap)
library(EnhancedVolcano)
library(RColorBrewer)
library(cowplot)
library(dplyr)
library(ggrepel)
```
```{r}
# getting the aggregated data
astro_data@meta.data
agg_data <- AggregateExpression(astro_data,
                                group.by='sample_id')
bulk_counts <- agg_data$RNA
# Generating sample level metadata
colData <- data.frame(
  AD_STATUS = rep(NA,ncol(bulk_counts)),
  row.names = colnames(bulk_counts)
)
```
```{r}
status_lookup <- c(
  "sample-1"  = "AD",
  "sample-2"  = "WT",
  "sample-3"  = "WT",
  "sample-4"  = "AD",
  "sample-5"  = "AD",
  "sample-6"  = "WT",
  "sample-7"  = "AD",
  "sample-8"  = "AD",
  "sample-9"  = "WT",
  "sample-10" = "WT"
)

colData$AD_STATUS <- status_lookup[rownames(colData)]
colData$AD_STATUS <- factor(colData$AD_STATUS)
```
# SANITY CHECK

```{r}
# Must be TRUE
all(colnames(bulk_counts) == rownames(colData))
# Must be TRUE as well
all(colnames(bulk_counts) %in% rownames(colData))

```
# RUNNING DESEQ2 !!!!!!!
```{r}
#Making the object for deseq2
deseq_matrix <- DESeqDataSetFromMatrix(countData = bulk_counts,
colData = colData,
design = ~ AD_STATUS)
```

# prefiltering step
```{r}
keep <- rowSums(counts(deseq_matrix)) >= 10
deseq_matrix <- deseq_matrix[keep,]
deseq_matrix
```
# changing what is considered the "baseline" for comparison for DESEQ2 away from alphabetical
```{r}
deseq_matrix$AD_STATUS <- relevel(deseq_matrix$AD_STATUS, ref = "WT")
```

# Diagnosing problem withrow names supplied being wrong lenth
```{r}
# 1. Length check
length(colnames(bulk_counts))
length(rownames(colData))

# 2. Identity + order check
identical(colnames(bulk_counts), rownames(colData))

# 3. See differences if any
setdiff(colnames(bulk_counts), rownames(colData))
setdiff(rownames(colData), colnames(bulk_counts))

# 4. Check AD_STATUS
str(colData$AD_STATUS)
table(colData$AD_STATUS)

```
#running DESEQ2
```{r}
deseq_matrix <- DESeq(deseq_matrix)
res <- results(deseq_matrix)
res['Aqp4',]
res['Gfap',]
```
```{r}
plotMA(res)
EnhancedVolcano(res,
    lab = rownames(res),
    x = 'log2FoldChange',
    y = 'pvalue')
```

